{"version":3,"file":"request-state.mjs","names":["AsyncLocalStorage"],"sources":["../../src/context/request-state.ts"],"sourcesContent":["import type { AsyncLocalStorage } from \"@better-auth/core/async_hooks\";\nimport { getAsyncLocalStorage } from \"@better-auth/core/async_hooks\";\nimport { __getBetterAuthGlobal } from \"./global\";\n\nexport type RequestStateWeakMap = WeakMap<object, any>;\n\nconst ensureAsyncStorage = async () => {\n\tconst betterAuthGlobal = __getBetterAuthGlobal();\n\tif (!betterAuthGlobal.context.requestStateAsyncStorage) {\n\t\tconst AsyncLocalStorage = await getAsyncLocalStorage();\n\t\tbetterAuthGlobal.context.requestStateAsyncStorage =\n\t\t\tnew AsyncLocalStorage<RequestStateWeakMap>();\n\t}\n\treturn betterAuthGlobal.context\n\t\t.requestStateAsyncStorage as AsyncLocalStorage<RequestStateWeakMap>;\n};\n\nexport async function getRequestStateAsyncLocalStorage() {\n\treturn ensureAsyncStorage();\n}\n\nexport async function hasRequestState() {\n\tconst als = await ensureAsyncStorage();\n\treturn als.getStore() !== undefined;\n}\n\nexport async function getCurrentRequestState(): Promise<RequestStateWeakMap> {\n\tconst als = await ensureAsyncStorage();\n\tconst store = als.getStore();\n\tif (!store) {\n\t\tthrow new Error(\n\t\t\t\"No request state found. Please make sure you are calling this function within a `runWithRequestState` callback.\",\n\t\t);\n\t}\n\treturn store;\n}\n\nexport async function runWithRequestState<T>(\n\tstore: RequestStateWeakMap,\n\tfn: () => T,\n): Promise<T> {\n\tconst als = await ensureAsyncStorage();\n\treturn als.run(store, fn);\n}\n\nexport interface RequestState<T> {\n\tget(): Promise<T>;\n\tset(value: T): Promise<void>;\n\n\t// A unique reference used as a key to identify this state within the request's WeakMap. Useful for debugging purposes.\n\treadonly ref: Readonly<object>;\n}\n\n/**\n * Defines a request-scoped state with lazy initialization.\n *\n * @param initFn - A function that initializes the state. It is called the first time `get()` is invoked within each request context, and only once per context.\n * @returns A RequestState object with `get` and `set` methods, and a unique `ref` for debugging.\n *\n * @example\n * const userState = defineRequestState(() => ({ id: '', name: '' }));\n * // Later, within a request context:\n * const user = await userState.get();\n */\nexport function defineRequestState<T>(\n\tinitFn: () => T | Promise<T>,\n): RequestState<T>;\nexport function defineRequestState(\n\tinitFn: () => any | Promise<any>,\n): RequestState<any> {\n\tconst ref = Object.freeze({});\n\treturn {\n\t\tget ref(): Readonly<object> {\n\t\t\treturn ref;\n\t\t},\n\t\tasync get() {\n\t\t\tconst store = await getCurrentRequestState();\n\t\t\tif (!store.has(ref)) {\n\t\t\t\tconst initialValue = await initFn();\n\t\t\t\tstore.set(ref, initialValue);\n\t\t\t\treturn initialValue;\n\t\t\t}\n\t\t\treturn store.get(ref);\n\t\t},\n\n\t\tasync set(value) {\n\t\t\tconst store = await getCurrentRequestState();\n\t\t\tstore.set(ref, value);\n\t\t},\n\t};\n}\n"],"mappings":";;;;AAMA,MAAM,qBAAqB,YAAY;CACtC,MAAM,mBAAmB,uBAAuB;AAChD,KAAI,CAAC,iBAAiB,QAAQ,0BAA0B;EACvD,MAAMA,sBAAoB,MAAM,sBAAsB;AACtD,mBAAiB,QAAQ,2BACxB,IAAIA,qBAAwC;;AAE9C,QAAO,iBAAiB,QACtB;;AAGH,eAAsB,mCAAmC;AACxD,QAAO,oBAAoB;;AAG5B,eAAsB,kBAAkB;AAEvC,SADY,MAAM,oBAAoB,EAC3B,UAAU,KAAK;;AAG3B,eAAsB,yBAAuD;CAE5E,MAAM,SADM,MAAM,oBAAoB,EACpB,UAAU;AAC5B,KAAI,CAAC,MACJ,OAAM,IAAI,MACT,kHACA;AAEF,QAAO;;AAGR,eAAsB,oBACrB,OACA,IACa;AAEb,SADY,MAAM,oBAAoB,EAC3B,IAAI,OAAO,GAAG;;AAyB1B,SAAgB,mBACf,QACoB;CACpB,MAAM,MAAM,OAAO,OAAO,EAAE,CAAC;AAC7B,QAAO;EACN,IAAI,MAAwB;AAC3B,UAAO;;EAER,MAAM,MAAM;GACX,MAAM,QAAQ,MAAM,wBAAwB;AAC5C,OAAI,CAAC,MAAM,IAAI,IAAI,EAAE;IACpB,MAAM,eAAe,MAAM,QAAQ;AACnC,UAAM,IAAI,KAAK,aAAa;AAC5B,WAAO;;AAER,UAAO,MAAM,IAAI,IAAI;;EAGtB,MAAM,IAAI,OAAO;AAEhB,IADc,MAAM,wBAAwB,EACtC,IAAI,KAAK,MAAM;;EAEtB"}