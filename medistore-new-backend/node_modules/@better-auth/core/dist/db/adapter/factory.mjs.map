{"version":3,"file":"factory.mjs","names":["debugLogs: { instance: string; args: any[] }[]","logger","transformedData: Record<string, any>","newFieldName: string","data","unsafe_model","select","transformedData","fieldName: string","transformedJoin: JoinConfig","from: string","to: string","requiredSelectField: string","limit: number","result: Record<string, any> | Record<string, any>[] | null","lazyLoadTransaction:\n\t\t\t| DBAdapter<BetterAuthOptions>[\"transaction\"]\n\t\t\t| null","adapter: DBAdapter<BetterAuthOptions>","join: JoinConfig | undefined","log","log: any[]","transactionId"],"sources":["../../../src/db/adapter/factory.ts"],"sourcesContent":["import { createLogger, getColorDepth, TTY_COLORS } from \"../../env\";\nimport { BetterAuthError } from \"../../error\";\nimport type { BetterAuthOptions } from \"../../types\";\nimport { safeJSONParse } from \"../../utils/json\";\nimport { getAuthTables } from \"../get-tables\";\nimport { initGetDefaultFieldName } from \"./get-default-field-name\";\nimport { initGetDefaultModelName } from \"./get-default-model-name\";\nimport { initGetFieldAttributes } from \"./get-field-attributes\";\nimport { initGetFieldName } from \"./get-field-name\";\nimport { initGetIdField } from \"./get-id-field\";\nimport { initGetModelName } from \"./get-model-name\";\nimport type {\n\tCleanedWhere,\n\tDBAdapter,\n\tDBTransactionAdapter,\n\tJoinConfig,\n\tJoinOption,\n\tWhere,\n} from \"./index\";\nimport type {\n\tAdapterFactoryConfig,\n\tAdapterFactoryOptions,\n\tAdapterTestDebugLogs,\n} from \"./types\";\nimport { withApplyDefault } from \"./utils\";\n\nexport {\n\tinitGetDefaultModelName,\n\tinitGetDefaultFieldName,\n\tinitGetModelName,\n\tinitGetFieldName,\n\tinitGetFieldAttributes,\n\tinitGetIdField,\n};\nexport * from \"./types\";\n\nlet debugLogs: { instance: string; args: any[] }[] = [];\nlet transactionId = -1;\n\nconst createAsIsTransaction =\n\t(adapter: DBAdapter<BetterAuthOptions>) =>\n\t<R>(fn: (trx: DBTransactionAdapter<BetterAuthOptions>) => Promise<R>) =>\n\t\tfn(adapter);\n\nexport type AdapterFactory = (\n\toptions: BetterAuthOptions,\n) => DBAdapter<BetterAuthOptions>;\n\nexport const createAdapterFactory =\n\t({\n\t\tadapter: customAdapter,\n\t\tconfig: cfg,\n\t}: AdapterFactoryOptions): AdapterFactory =>\n\t(options: BetterAuthOptions): DBAdapter<BetterAuthOptions> => {\n\t\tconst uniqueAdapterFactoryInstanceId = Math.random()\n\t\t\t.toString(36)\n\t\t\t.substring(2, 15);\n\n\t\tconst config = {\n\t\t\t...cfg,\n\t\t\tsupportsBooleans: cfg.supportsBooleans ?? true,\n\t\t\tsupportsDates: cfg.supportsDates ?? true,\n\t\t\tsupportsJSON: cfg.supportsJSON ?? false,\n\t\t\tadapterName: cfg.adapterName ?? cfg.adapterId,\n\t\t\tsupportsNumericIds: cfg.supportsNumericIds ?? true,\n\t\t\tsupportsUUIDs: cfg.supportsUUIDs ?? false,\n\t\t\tsupportsArrays: cfg.supportsArrays ?? false,\n\t\t\ttransaction: cfg.transaction ?? false,\n\t\t\tdisableTransformInput: cfg.disableTransformInput ?? false,\n\t\t\tdisableTransformOutput: cfg.disableTransformOutput ?? false,\n\t\t\tdisableTransformJoin: cfg.disableTransformJoin ?? false,\n\t\t} satisfies AdapterFactoryConfig;\n\n\t\tconst useNumberId =\n\t\t\toptions.advanced?.database?.useNumberId === true ||\n\t\t\toptions.advanced?.database?.generateId === \"serial\";\n\t\tif (useNumberId && config.supportsNumericIds === false) {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t`[${config.adapterName}] Your database or database adapter does not support numeric ids. Please disable \"useNumberId\" in your config.`,\n\t\t\t);\n\t\t}\n\n\t\t// End-user's Better-Auth instance's schema\n\t\tconst schema = getAuthTables(options);\n\n\t\tconst debugLog = (...args: any[]) => {\n\t\t\tif (config.debugLogs === true || typeof config.debugLogs === \"object\") {\n\t\t\t\tconst logger = createLogger({ level: \"info\" });\n\t\t\t\t// If we're running adapter tests, we'll keep debug logs in memory, then print them out if a test fails.\n\t\t\t\tif (\n\t\t\t\t\ttypeof config.debugLogs === \"object\" &&\n\t\t\t\t\t\"isRunningAdapterTests\" in config.debugLogs\n\t\t\t\t) {\n\t\t\t\t\tif (config.debugLogs.isRunningAdapterTests) {\n\t\t\t\t\t\targs.shift(); // Removes the {method: \"...\"} object from the args array.\n\t\t\t\t\t\tdebugLogs.push({ instance: uniqueAdapterFactoryInstanceId, args });\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\ttypeof config.debugLogs === \"object\" &&\n\t\t\t\t\tconfig.debugLogs.logCondition &&\n\t\t\t\t\t!config.debugLogs.logCondition?.()\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (typeof args[0] === \"object\" && \"method\" in args[0]) {\n\t\t\t\t\tconst method = args.shift().method;\n\t\t\t\t\t// Make sure the method is enabled in the config.\n\t\t\t\t\tif (typeof config.debugLogs === \"object\") {\n\t\t\t\t\t\tif (method === \"create\" && !config.debugLogs.create) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (method === \"update\" && !config.debugLogs.update) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tmethod === \"updateMany\" &&\n\t\t\t\t\t\t\t!config.debugLogs.updateMany\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (method === \"findOne\" && !config.debugLogs.findOne) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (method === \"findMany\" && !config.debugLogs.findMany) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (method === \"delete\" && !config.debugLogs.delete) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tmethod === \"deleteMany\" &&\n\t\t\t\t\t\t\t!config.debugLogs.deleteMany\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (method === \"count\" && !config.debugLogs.count) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlogger.info(`[${config.adapterName}]`, ...args);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.info(`[${config.adapterName}]`, ...args);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst logger = createLogger(options.logger);\n\n\t\tconst getDefaultModelName = initGetDefaultModelName({\n\t\t\tusePlural: config.usePlural,\n\t\t\tschema,\n\t\t});\n\n\t\tconst getDefaultFieldName = initGetDefaultFieldName({\n\t\t\tusePlural: config.usePlural,\n\t\t\tschema,\n\t\t});\n\n\t\tconst getModelName = initGetModelName({\n\t\t\tusePlural: config.usePlural,\n\t\t\tschema,\n\t\t});\n\t\tconst getFieldName = initGetFieldName({\n\t\t\tschema,\n\t\t\tusePlural: config.usePlural,\n\t\t});\n\n\t\tconst idField = initGetIdField({\n\t\t\tschema,\n\t\t\toptions,\n\t\t\tusePlural: config.usePlural,\n\t\t\tdisableIdGeneration: config.disableIdGeneration,\n\t\t\tcustomIdGenerator: config.customIdGenerator,\n\t\t\tsupportsUUIDs: config.supportsUUIDs,\n\t\t});\n\n\t\tconst getFieldAttributes = initGetFieldAttributes({\n\t\t\tschema,\n\t\t\toptions,\n\t\t\tusePlural: config.usePlural,\n\t\t\tdisableIdGeneration: config.disableIdGeneration,\n\t\t\tcustomIdGenerator: config.customIdGenerator,\n\t\t});\n\n\t\tconst transformInput = async (\n\t\t\tdata: Record<string, any>,\n\t\t\tdefaultModelName: string,\n\t\t\taction: \"create\" | \"update\" | \"findOne\" | \"findMany\",\n\t\t\tforceAllowId?: boolean,\n\t\t) => {\n\t\t\tconst transformedData: Record<string, any> = {};\n\t\t\tconst fields = schema[defaultModelName]!.fields;\n\n\t\t\tconst newMappedKeys = config.mapKeysTransformInput ?? {};\n\t\t\tconst useNumberId =\n\t\t\t\toptions.advanced?.database?.useNumberId ||\n\t\t\t\toptions.advanced?.database?.generateId === \"serial\";\n\t\t\tfields.id = idField({\n\t\t\t\tcustomModelName: defaultModelName,\n\t\t\t\tforceAllowId: forceAllowId && \"id\" in data,\n\t\t\t});\n\t\t\tfor (const field in fields) {\n\t\t\t\tlet value = data[field];\n\t\t\t\tconst fieldAttributes = fields[field];\n\n\t\t\t\tconst newFieldName: string =\n\t\t\t\t\tnewMappedKeys[field] || fields[field]!.fieldName || field;\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined &&\n\t\t\t\t\t((fieldAttributes!.defaultValue === undefined &&\n\t\t\t\t\t\t!fieldAttributes!.transform?.input &&\n\t\t\t\t\t\t!(action === \"update\" && fieldAttributes!.onUpdate)) ||\n\t\t\t\t\t\t(action === \"update\" && !fieldAttributes!.onUpdate))\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// In some endpoints (like signUpEmail) where there isn't proper Zod validation,\n\t\t\t\t// we might receive a date as a string (this is because of the client converting the Date to a string\n\t\t\t\t// when sending to the server). Because of this, we'll convert the string to a Date.\n\t\t\t\tif (\n\t\t\t\t\tfieldAttributes &&\n\t\t\t\t\tfieldAttributes.type === \"date\" &&\n\t\t\t\t\t!(value instanceof Date) &&\n\t\t\t\t\ttypeof value === \"string\"\n\t\t\t\t) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvalue = new Date(value);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tlogger.error(\"[Adapter Factory] Failed to convert string to date\", {\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tfield,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If the value is undefined, but the fieldAttr provides a `defaultValue`, then we'll use that.\n\t\t\t\tlet newValue = withApplyDefault(value, fieldAttributes!, action);\n\n\t\t\t\t// If the field attr provides a custom transform input, then we'll let it handle the value transformation.\n\t\t\t\t// Afterwards, we'll continue to apply the default transformations just to make sure it saves in the correct format.\n\t\t\t\tif (fieldAttributes!.transform?.input) {\n\t\t\t\t\tnewValue = await fieldAttributes!.transform.input(newValue);\n\t\t\t\t}\n\n\t\t\t\tif (fieldAttributes!.references?.field === \"id\" && useNumberId) {\n\t\t\t\t\tif (Array.isArray(newValue)) {\n\t\t\t\t\t\tnewValue = newValue.map((x) => (x !== null ? Number(x) : null));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewValue = newValue !== null ? Number(newValue) : null;\n\t\t\t\t\t}\n\t\t\t\t} else if (\n\t\t\t\t\tconfig.supportsJSON === false &&\n\t\t\t\t\ttypeof newValue === \"object\" &&\n\t\t\t\t\tfieldAttributes!.type === \"json\"\n\t\t\t\t) {\n\t\t\t\t\tnewValue = JSON.stringify(newValue);\n\t\t\t\t} else if (\n\t\t\t\t\tconfig.supportsArrays === false &&\n\t\t\t\t\tArray.isArray(newValue) &&\n\t\t\t\t\t(fieldAttributes!.type === \"string[]\" ||\n\t\t\t\t\t\tfieldAttributes!.type === \"number[]\")\n\t\t\t\t) {\n\t\t\t\t\tnewValue = JSON.stringify(newValue);\n\t\t\t\t} else if (\n\t\t\t\t\tconfig.supportsDates === false &&\n\t\t\t\t\tnewValue instanceof Date &&\n\t\t\t\t\tfieldAttributes!.type === \"date\"\n\t\t\t\t) {\n\t\t\t\t\tnewValue = newValue.toISOString();\n\t\t\t\t} else if (\n\t\t\t\t\tconfig.supportsBooleans === false &&\n\t\t\t\t\ttypeof newValue === \"boolean\"\n\t\t\t\t) {\n\t\t\t\t\tnewValue = newValue ? 1 : 0;\n\t\t\t\t}\n\n\t\t\t\tif (config.customTransformInput) {\n\t\t\t\t\tnewValue = config.customTransformInput({\n\t\t\t\t\t\tdata: newValue,\n\t\t\t\t\t\taction,\n\t\t\t\t\t\tfield: newFieldName,\n\t\t\t\t\t\tfieldAttributes: fieldAttributes!,\n\t\t\t\t\t\tmodel: getModelName(defaultModelName),\n\t\t\t\t\t\tschema,\n\t\t\t\t\t\toptions,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (newValue !== undefined) {\n\t\t\t\t\ttransformedData[newFieldName] = newValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn transformedData;\n\t\t};\n\n\t\tconst transformOutput = async (\n\t\t\tdata: Record<string, any> | null,\n\t\t\tunsafe_model: string,\n\t\t\tselect: string[] = [],\n\t\t\tjoin: JoinConfig | undefined,\n\t\t) => {\n\t\t\tconst transformSingleOutput = async (\n\t\t\t\tdata: Record<string, any> | null,\n\t\t\t\tunsafe_model: string,\n\t\t\t\tselect: string[] = [],\n\t\t\t) => {\n\t\t\t\tif (!data) return null;\n\t\t\t\tconst newMappedKeys = config.mapKeysTransformOutput ?? {};\n\t\t\t\tconst transformedData: Record<string, any> = {};\n\t\t\t\tconst tableSchema = schema[getDefaultModelName(unsafe_model)]!.fields;\n\t\t\t\tconst idKey = Object.entries(newMappedKeys).find(\n\t\t\t\t\t([_, v]) => v === \"id\",\n\t\t\t\t)?.[0];\n\t\t\t\tconst useNumberId =\n\t\t\t\t\toptions.advanced?.database?.useNumberId ||\n\t\t\t\t\toptions.advanced?.database?.generateId === \"serial\";\n\t\t\t\ttableSchema[idKey ?? \"id\"] = {\n\t\t\t\t\ttype: useNumberId ? \"number\" : \"string\",\n\t\t\t\t};\n\t\t\t\tfor (const key in tableSchema) {\n\t\t\t\t\tif (select.length && !select.includes(key)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst field = tableSchema[key];\n\t\t\t\t\tif (field) {\n\t\t\t\t\t\tconst originalKey = field.fieldName || key;\n\n\t\t\t\t\t\t// If the field is mapped, we'll use the mapped key. Otherwise, we'll use the original key.\n\t\t\t\t\t\tlet newValue =\n\t\t\t\t\t\t\tdata[\n\t\t\t\t\t\t\t\tObject.entries(newMappedKeys).find(\n\t\t\t\t\t\t\t\t\t([_, v]) => v === originalKey,\n\t\t\t\t\t\t\t\t)?.[0] || originalKey\n\t\t\t\t\t\t\t];\n\n\t\t\t\t\t\tif (field.transform?.output) {\n\t\t\t\t\t\t\tnewValue = await field.transform.output(newValue);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst newFieldName: string = newMappedKeys[key] || key;\n\n\t\t\t\t\t\tif (originalKey === \"id\" || field.references?.field === \"id\") {\n\t\t\t\t\t\t\t// Even if `useNumberId` is true, we must always return a string `id` output.\n\t\t\t\t\t\t\tif (typeof newValue !== \"undefined\" && newValue !== null)\n\t\t\t\t\t\t\t\tnewValue = String(newValue);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tconfig.supportsJSON === false &&\n\t\t\t\t\t\t\ttypeof newValue === \"string\" &&\n\t\t\t\t\t\t\tfield.type === \"json\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnewValue = safeJSONParse(newValue);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tconfig.supportsArrays === false &&\n\t\t\t\t\t\t\ttypeof newValue === \"string\" &&\n\t\t\t\t\t\t\t(field.type === \"string[]\" || field.type === \"number[]\")\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnewValue = safeJSONParse(newValue);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tconfig.supportsDates === false &&\n\t\t\t\t\t\t\ttypeof newValue === \"string\" &&\n\t\t\t\t\t\t\tfield.type === \"date\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnewValue = new Date(newValue);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tconfig.supportsBooleans === false &&\n\t\t\t\t\t\t\ttypeof newValue === \"number\" &&\n\t\t\t\t\t\t\tfield.type === \"boolean\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnewValue = newValue === 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (config.customTransformOutput) {\n\t\t\t\t\t\t\tnewValue = config.customTransformOutput({\n\t\t\t\t\t\t\t\tdata: newValue,\n\t\t\t\t\t\t\t\tfield: newFieldName,\n\t\t\t\t\t\t\t\tfieldAttributes: field,\n\t\t\t\t\t\t\t\tselect,\n\t\t\t\t\t\t\t\tmodel: getModelName(unsafe_model),\n\t\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttransformedData[newFieldName] = newValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn transformedData as any;\n\t\t\t};\n\n\t\t\tif (!join || Object.keys(join).length === 0) {\n\t\t\t\treturn await transformSingleOutput(data, unsafe_model, select);\n\t\t\t}\n\n\t\t\tunsafe_model = getDefaultModelName(unsafe_model);\n\t\t\t// for now we just transform the base model\n\t\t\t// later we append the joined models to this object.\n\t\t\tconst transformedData: Record<string, any> = await transformSingleOutput(\n\t\t\t\tdata,\n\t\t\t\tunsafe_model,\n\t\t\t\tselect,\n\t\t\t);\n\n\t\t\t// Get all the models that are required to be joined.\n\t\t\tconst requiredModels = Object.entries(join).map(\n\t\t\t\t([model, joinConfig]) => ({\n\t\t\t\t\tmodelName: getModelName(model),\n\t\t\t\t\tdefaultModelName: getDefaultModelName(model),\n\t\t\t\t\tjoinConfig,\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tif (!data) return null;\n\t\t\t// Data is now the base model object directly (not wrapped under a key)\n\n\t\t\tfor (const {\n\t\t\t\tmodelName,\n\t\t\t\tdefaultModelName,\n\t\t\t\tjoinConfig,\n\t\t\t} of requiredModels) {\n\t\t\t\tlet joinedData = await (async () => {\n\t\t\t\t\tif (options.experimental?.joins) {\n\t\t\t\t\t\tconst result = data[modelName];\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// doesn't support joins, so fallback to handleFallbackJoin\n\t\t\t\t\t\tconst result = await handleFallbackJoin({\n\t\t\t\t\t\t\tbaseModel: unsafe_model,\n\t\t\t\t\t\t\tbaseData: transformedData,\n\t\t\t\t\t\t\tjoinModel: modelName,\n\t\t\t\t\t\t\tspecificJoinConfig: joinConfig,\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t})();\n\n\t\t\t\t// If joinedData is undefined, initialize it based on relationship type\n\t\t\t\tif (joinedData === undefined || joinedData === null) {\n\t\t\t\t\tjoinedData = joinConfig.relation === \"one-to-one\" ? null : [];\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tjoinConfig.relation === \"one-to-many\" &&\n\t\t\t\t\t!Array.isArray(joinedData)\n\t\t\t\t) {\n\t\t\t\t\tjoinedData = [joinedData];\n\t\t\t\t}\n\n\t\t\t\tconst transformed = [];\n\n\t\t\t\tif (Array.isArray(joinedData)) {\n\t\t\t\t\tfor (const item of joinedData) {\n\t\t\t\t\t\tconst transformedItem = await transformSingleOutput(\n\t\t\t\t\t\t\titem,\n\t\t\t\t\t\t\tmodelName,\n\t\t\t\t\t\t\t[],\n\t\t\t\t\t\t);\n\t\t\t\t\t\ttransformed.push(transformedItem);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst transformedItem = await transformSingleOutput(\n\t\t\t\t\t\tjoinedData,\n\t\t\t\t\t\tmodelName,\n\t\t\t\t\t\t[],\n\t\t\t\t\t);\n\t\t\t\t\ttransformed.push(transformedItem);\n\t\t\t\t}\n\n\t\t\t\tconst result =\n\t\t\t\t\tjoinConfig.relation === \"one-to-one\" ? transformed[0] : transformed;\n\t\t\t\ttransformedData[defaultModelName] = result ?? null;\n\t\t\t}\n\n\t\t\treturn transformedData as any;\n\t\t};\n\n\t\tconst transformWhereClause = <W extends Where[] | undefined>({\n\t\t\tmodel,\n\t\t\twhere,\n\t\t\taction,\n\t\t}: {\n\t\t\twhere: W;\n\t\t\tmodel: string;\n\t\t\taction:\n\t\t\t\t| \"create\"\n\t\t\t\t| \"update\"\n\t\t\t\t| \"findOne\"\n\t\t\t\t| \"findMany\"\n\t\t\t\t| \"updateMany\"\n\t\t\t\t| \"delete\"\n\t\t\t\t| \"deleteMany\"\n\t\t\t\t| \"count\";\n\t\t}): W extends undefined ? undefined : CleanedWhere[] => {\n\t\t\tif (!where) return undefined as any;\n\t\t\tconst newMappedKeys = config.mapKeysTransformInput ?? {};\n\n\t\t\treturn where.map((w) => {\n\t\t\t\tconst {\n\t\t\t\t\tfield: unsafe_field,\n\t\t\t\t\tvalue,\n\t\t\t\t\toperator = \"eq\",\n\t\t\t\t\tconnector = \"AND\",\n\t\t\t\t} = w;\n\t\t\t\tif (operator === \"in\") {\n\t\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\t\tthrow new BetterAuthError(\"Value must be an array\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet newValue = value;\n\n\t\t\t\tconst defaultModelName = getDefaultModelName(model);\n\t\t\t\tconst defaultFieldName = getDefaultFieldName({\n\t\t\t\t\tfield: unsafe_field,\n\t\t\t\t\tmodel,\n\t\t\t\t});\n\t\t\t\tconst fieldName: string =\n\t\t\t\t\tnewMappedKeys[defaultFieldName] ||\n\t\t\t\t\tgetFieldName({\n\t\t\t\t\t\tfield: defaultFieldName,\n\t\t\t\t\t\tmodel: defaultModelName,\n\t\t\t\t\t});\n\n\t\t\t\tconst fieldAttr = getFieldAttributes({\n\t\t\t\t\tfield: defaultFieldName,\n\t\t\t\t\tmodel: defaultModelName,\n\t\t\t\t});\n\n\t\t\t\tconst useNumberId =\n\t\t\t\t\toptions.advanced?.database?.useNumberId ||\n\t\t\t\t\toptions.advanced?.database?.generateId === \"serial\";\n\n\t\t\t\tif (\n\t\t\t\t\tdefaultFieldName === \"id\" ||\n\t\t\t\t\tfieldAttr!.references?.field === \"id\"\n\t\t\t\t) {\n\t\t\t\t\tif (useNumberId) {\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tnewValue = value.map(Number);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewValue = Number(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tfieldAttr.type === \"date\" &&\n\t\t\t\t\tvalue instanceof Date &&\n\t\t\t\t\t!config.supportsDates\n\t\t\t\t) {\n\t\t\t\t\tnewValue = value.toISOString();\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tfieldAttr.type === \"boolean\" &&\n\t\t\t\t\ttypeof value === \"boolean\" &&\n\t\t\t\t\t!config.supportsBooleans\n\t\t\t\t) {\n\t\t\t\t\tnewValue = value ? 1 : 0;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tfieldAttr.type === \"json\" &&\n\t\t\t\t\ttypeof value === \"object\" &&\n\t\t\t\t\t!config.supportsJSON\n\t\t\t\t) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst stringifiedJSON = JSON.stringify(value);\n\t\t\t\t\t\tnewValue = stringifiedJSON;\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Failed to stringify JSON value for field ${fieldName}`,\n\t\t\t\t\t\t\t{ cause: error },\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (config.customTransformInput) {\n\t\t\t\t\tnewValue = config.customTransformInput({\n\t\t\t\t\t\tdata: newValue,\n\t\t\t\t\t\tfieldAttributes: fieldAttr,\n\t\t\t\t\t\tfield: fieldName,\n\t\t\t\t\t\tmodel: getModelName(model),\n\t\t\t\t\t\tschema,\n\t\t\t\t\t\toptions,\n\t\t\t\t\t\taction,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\toperator,\n\t\t\t\t\tconnector,\n\t\t\t\t\tfield: fieldName,\n\t\t\t\t\tvalue: newValue,\n\t\t\t\t} satisfies CleanedWhere;\n\t\t\t}) as any;\n\t\t};\n\n\t\tconst transformJoinClause = (\n\t\t\tbaseModel: string,\n\t\t\tunsanitizedJoin: JoinOption | undefined,\n\t\t\tselect: string[] | undefined,\n\t\t): { join: JoinConfig; select: string[] | undefined } | undefined => {\n\t\t\tif (!unsanitizedJoin) return undefined;\n\t\t\tif (Object.keys(unsanitizedJoin).length === 0) return undefined;\n\t\t\tconst transformedJoin: JoinConfig = {};\n\t\t\tfor (const [model, join] of Object.entries(unsanitizedJoin)) {\n\t\t\t\tif (!join) continue;\n\t\t\t\tconst defaultModelName = getDefaultModelName(model);\n\t\t\t\tconst defaultBaseModelName = getDefaultModelName(baseModel);\n\n\t\t\t\t// First, check if the joined model has FKs to the base model (forward join)\n\t\t\t\tlet foreignKeys = Object.entries(\n\t\t\t\t\tschema[defaultModelName]!.fields,\n\t\t\t\t).filter(\n\t\t\t\t\t([field, fieldAttributes]) =>\n\t\t\t\t\t\tfieldAttributes.references &&\n\t\t\t\t\t\tgetDefaultModelName(fieldAttributes.references.model) ===\n\t\t\t\t\t\t\tdefaultBaseModelName,\n\t\t\t\t);\n\n\t\t\t\tlet isForwardJoin = true;\n\n\t\t\t\t// If no forward join found, check backwards: does the base model have FKs to the joined model?\n\t\t\t\tif (!foreignKeys.length) {\n\t\t\t\t\tforeignKeys = Object.entries(\n\t\t\t\t\t\tschema[defaultBaseModelName]!.fields,\n\t\t\t\t\t).filter(\n\t\t\t\t\t\t([field, fieldAttributes]) =>\n\t\t\t\t\t\t\tfieldAttributes.references &&\n\t\t\t\t\t\t\tgetDefaultModelName(fieldAttributes.references.model) ===\n\t\t\t\t\t\t\t\tdefaultModelName,\n\t\t\t\t\t);\n\t\t\t\t\tisForwardJoin = false;\n\t\t\t\t}\n\n\t\t\t\tif (!foreignKeys.length) {\n\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t`No foreign key found for model ${model} and base model ${baseModel} while performing join operation.`,\n\t\t\t\t\t);\n\t\t\t\t} else if (foreignKeys.length > 1) {\n\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t`Multiple foreign keys found for model ${model} and base model ${baseModel} while performing join operation. Only one foreign key is supported.`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst [foreignKey, foreignKeyAttributes] = foreignKeys[0]!;\n\t\t\t\tif (!foreignKeyAttributes.references) {\n\t\t\t\t\t// this should never happen, as we filter for references in the foreign keys.\n\t\t\t\t\t// it's here for typescript to be happy.\n\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t`No references found for foreign key ${foreignKey} on model ${model} while performing join operation.`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet from: string;\n\t\t\t\tlet to: string;\n\t\t\t\tlet requiredSelectField: string;\n\n\t\t\t\tif (isForwardJoin) {\n\t\t\t\t\t// joined model has FK to base model\n\t\t\t\t\t// The field we need in select is the referenced field in the base model\n\t\t\t\t\trequiredSelectField = foreignKeyAttributes.references.field;\n\t\t\t\t\tfrom = getFieldName({\n\t\t\t\t\t\tmodel: baseModel,\n\t\t\t\t\t\tfield: requiredSelectField,\n\t\t\t\t\t});\n\n\t\t\t\t\tto = getFieldName({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tfield: foreignKey,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// base model has FK to joined model\n\t\t\t\t\t// The field we need in select is the foreign key field in the base model\n\t\t\t\t\trequiredSelectField = foreignKey;\n\t\t\t\t\tfrom = getFieldName({\n\t\t\t\t\t\tmodel: baseModel,\n\t\t\t\t\t\tfield: requiredSelectField,\n\t\t\t\t\t});\n\n\t\t\t\t\tto = getFieldName({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tfield: foreignKeyAttributes.references.field,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Ensure the required field is in select if select is provided\n\t\t\t\tif (select && !select.includes(requiredSelectField)) {\n\t\t\t\t\tselect.push(requiredSelectField);\n\t\t\t\t}\n\n\t\t\t\tconst isUnique =\n\t\t\t\t\tto === \"id\" ? true : (foreignKeyAttributes.unique ?? false);\n\n\t\t\t\tlet limit: number =\n\t\t\t\t\toptions.advanced?.database?.defaultFindManyLimit ?? 100;\n\t\t\t\tif (isUnique) {\n\t\t\t\t\tlimit = 1;\n\t\t\t\t} else if (typeof join === \"object\" && typeof join.limit === \"number\") {\n\t\t\t\t\tlimit = join.limit;\n\t\t\t\t}\n\n\t\t\t\ttransformedJoin[getModelName(model)] = {\n\t\t\t\t\ton: {\n\t\t\t\t\t\tfrom,\n\t\t\t\t\t\tto,\n\t\t\t\t\t},\n\t\t\t\t\tlimit,\n\t\t\t\t\trelation: isUnique ? \"one-to-one\" : \"one-to-many\",\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn { join: transformedJoin, select };\n\t\t};\n\n\t\t/**\n\t\t * Handle joins by making separate queries and combining results (fallback for adapters that don't support native joins).\n\t\t */\n\t\tconst handleFallbackJoin = async <T extends Record<string, any> | null>({\n\t\t\tbaseModel,\n\t\t\tbaseData,\n\t\t\tjoinModel,\n\t\t\tspecificJoinConfig: joinConfig,\n\t\t}: {\n\t\t\tbaseModel: string;\n\t\t\tbaseData: T;\n\t\t\tjoinModel: string;\n\t\t\tspecificJoinConfig: JoinConfig[number];\n\t\t}) => {\n\t\t\tif (!baseData) return baseData;\n\t\t\tconst modelName = getModelName(joinModel);\n\t\t\tconst field = joinConfig.on.to;\n\t\t\tconst value =\n\t\t\t\tbaseData[\n\t\t\t\t\tgetDefaultFieldName({ field: joinConfig.on.from, model: baseModel })\n\t\t\t\t];\n\n\t\t\tif (value === null || value === undefined) {\n\t\t\t\t// If there is no value, it could mean that the query used a `select` clause that didn't include the field.\n\t\t\t\t// or the query result is purely empty.\n\t\t\t\t// In any case, we return null/empty array.\n\t\t\t\treturn joinConfig.relation === \"one-to-one\" ? null : [];\n\t\t\t}\n\t\t\tlet result: Record<string, any> | Record<string, any>[] | null;\n\t\t\tconst where = transformWhereClause({\n\t\t\t\tmodel: modelName,\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\toperator: \"eq\",\n\t\t\t\t\t\tconnector: \"AND\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\taction: \"findOne\",\n\t\t\t});\n\t\t\ttry {\n\t\t\t\tif (joinConfig.relation === \"one-to-one\") {\n\t\t\t\t\tresult = await adapterInstance.findOne<Record<string, any>>({\n\t\t\t\t\t\tmodel: modelName,\n\t\t\t\t\t\twhere: where,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tconst limit =\n\t\t\t\t\t\tjoinConfig.limit ??\n\t\t\t\t\t\toptions.advanced?.database?.defaultFindManyLimit ??\n\t\t\t\t\t\t100;\n\t\t\t\t\tresult = await adapterInstance.findMany<Record<string, any>>({\n\t\t\t\t\t\tmodel: modelName,\n\t\t\t\t\t\twhere: where,\n\t\t\t\t\t\tlimit,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(`Failed to query fallback join for model ${modelName}:`, {\n\t\t\t\t\twhere,\n\t\t\t\t\tlimit: joinConfig.limit,\n\t\t\t\t});\n\t\t\t\tconsole.error(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\tconst adapterInstance = customAdapter({\n\t\t\toptions,\n\t\t\tschema,\n\t\t\tdebugLog,\n\t\t\tgetFieldName,\n\t\t\tgetModelName,\n\t\t\tgetDefaultModelName,\n\t\t\tgetDefaultFieldName,\n\t\t\tgetFieldAttributes,\n\t\t\ttransformInput,\n\t\t\ttransformOutput,\n\t\t\ttransformWhereClause,\n\t\t});\n\n\t\tlet lazyLoadTransaction:\n\t\t\t| DBAdapter<BetterAuthOptions>[\"transaction\"]\n\t\t\t| null = null;\n\t\tconst adapter: DBAdapter<BetterAuthOptions> = {\n\t\t\ttransaction: async (cb) => {\n\t\t\t\tif (!lazyLoadTransaction) {\n\t\t\t\t\tif (!config.transaction) {\n\t\t\t\t\t\tlazyLoadTransaction = createAsIsTransaction(adapter);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t`[${config.adapterName}] - Using provided transaction implementation.`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tlazyLoadTransaction = config.transaction;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn lazyLoadTransaction(cb);\n\t\t\t},\n\t\t\tcreate: async <T extends Record<string, any>, R = T>({\n\t\t\t\tdata: unsafeData,\n\t\t\t\tmodel: unsafeModel,\n\t\t\t\tselect,\n\t\t\t\tforceAllowId = false,\n\t\t\t}: {\n\t\t\t\tmodel: string;\n\t\t\t\tdata: T;\n\t\t\t\tselect?: string[];\n\t\t\t\tforceAllowId?: boolean;\n\t\t\t}): Promise<R> => {\n\t\t\t\ttransactionId++;\n\t\t\t\tconst thisTransactionId = transactionId;\n\t\t\t\tconst model = getModelName(unsafeModel);\n\t\t\t\tunsafeModel = getDefaultModelName(unsafeModel);\n\t\t\t\tif (\n\t\t\t\t\t\"id\" in unsafeData &&\n\t\t\t\t\ttypeof unsafeData.id !== \"undefined\" &&\n\t\t\t\t\t!forceAllowId\n\t\t\t\t) {\n\t\t\t\t\t// The reason why `forceAllowId` was introduced was because we used to handle\n\t\t\t\t\t// id generation ourselves (eg adapter.create({ data: { id: \"123\" } }))\n\t\t\t\t\t// This was bad as certain things (such as number ids) would not work as expected.\n\t\t\t\t\t// Since then, we have introduced the `forceAllowId` parameter to allow users to\n\t\t\t\t\t// bypass this check. Otherwise, we would throw a warning stating that the id will be ignored\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`[${config.adapterName}] - You are trying to create a record with an id. This is not allowed as we handle id generation for you, unless you pass in the \\`forceAllowId\\` parameter. The id will be ignored.`,\n\t\t\t\t\t);\n\t\t\t\t\tconst err = new Error();\n\t\t\t\t\tconst stack = err.stack\n\t\t\t\t\t\t?.split(\"\\n\")\n\t\t\t\t\t\t.filter((_, i) => i !== 1)\n\t\t\t\t\t\t.join(\"\\n\")\n\t\t\t\t\t\t.replace(\"Error:\", \"Create method with `id` being called at:\");\n\t\t\t\t\tconsole.log(stack);\n\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\tunsafeData.id = undefined;\n\t\t\t\t}\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"create\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(1, 4)}`,\n\t\t\t\t\t`${formatMethod(\"create\")} ${formatAction(\"Unsafe Input\")}:`,\n\t\t\t\t\t{ model, data: unsafeData },\n\t\t\t\t);\n\t\t\t\tlet data = unsafeData;\n\t\t\t\tif (!config.disableTransformInput) {\n\t\t\t\t\tdata = (await transformInput(\n\t\t\t\t\t\tunsafeData,\n\t\t\t\t\t\tunsafeModel,\n\t\t\t\t\t\t\"create\",\n\t\t\t\t\t\tforceAllowId,\n\t\t\t\t\t)) as T;\n\t\t\t\t}\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"create\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(2, 4)}`,\n\t\t\t\t\t`${formatMethod(\"create\")} ${formatAction(\"Parsed Input\")}:`,\n\t\t\t\t\t{ model, data },\n\t\t\t\t);\n\t\t\t\tconst res = await adapterInstance.create<T>({ data, model });\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"create\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(3, 4)}`,\n\t\t\t\t\t`${formatMethod(\"create\")} ${formatAction(\"DB Result\")}:`,\n\t\t\t\t\t{ model, res },\n\t\t\t\t);\n\t\t\t\tlet transformed = res as any;\n\t\t\t\tif (!config.disableTransformOutput) {\n\t\t\t\t\ttransformed = await transformOutput(\n\t\t\t\t\t\tres as any,\n\t\t\t\t\t\tunsafeModel,\n\t\t\t\t\t\tselect,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"create\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(4, 4)}`,\n\t\t\t\t\t`${formatMethod(\"create\")} ${formatAction(\"Parsed Result\")}:`,\n\t\t\t\t\t{ model, data: transformed },\n\t\t\t\t);\n\t\t\t\treturn transformed;\n\t\t\t},\n\t\t\tupdate: async <T>({\n\t\t\t\tmodel: unsafeModel,\n\t\t\t\twhere: unsafeWhere,\n\t\t\t\tupdate: unsafeData,\n\t\t\t}: {\n\t\t\t\tmodel: string;\n\t\t\t\twhere: Where[];\n\t\t\t\tupdate: Record<string, any>;\n\t\t\t}): Promise<T | null> => {\n\t\t\t\ttransactionId++;\n\t\t\t\tconst thisTransactionId = transactionId;\n\t\t\t\tunsafeModel = getDefaultModelName(unsafeModel);\n\t\t\t\tconst model = getModelName(unsafeModel);\n\t\t\t\tconst where = transformWhereClause({\n\t\t\t\t\tmodel: unsafeModel,\n\t\t\t\t\twhere: unsafeWhere,\n\t\t\t\t\taction: \"update\",\n\t\t\t\t});\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"update\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(1, 4)}`,\n\t\t\t\t\t`${formatMethod(\"update\")} ${formatAction(\"Unsafe Input\")}:`,\n\t\t\t\t\t{ model, data: unsafeData },\n\t\t\t\t);\n\t\t\t\tlet data = unsafeData as T;\n\t\t\t\tif (!config.disableTransformInput) {\n\t\t\t\t\tdata = (await transformInput(unsafeData, unsafeModel, \"update\")) as T;\n\t\t\t\t}\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"update\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(2, 4)}`,\n\t\t\t\t\t`${formatMethod(\"update\")} ${formatAction(\"Parsed Input\")}:`,\n\t\t\t\t\t{ model, data },\n\t\t\t\t);\n\t\t\t\tconst res = await adapterInstance.update<T>({\n\t\t\t\t\tmodel,\n\t\t\t\t\twhere,\n\t\t\t\t\tupdate: data,\n\t\t\t\t});\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"update\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(3, 4)}`,\n\t\t\t\t\t`${formatMethod(\"update\")} ${formatAction(\"DB Result\")}:`,\n\t\t\t\t\t{ model, data: res },\n\t\t\t\t);\n\t\t\t\tlet transformed = res as any;\n\t\t\t\tif (!config.disableTransformOutput) {\n\t\t\t\t\ttransformed = await transformOutput(\n\t\t\t\t\t\tres as any,\n\t\t\t\t\t\tunsafeModel,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"update\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(4, 4)}`,\n\t\t\t\t\t`${formatMethod(\"update\")} ${formatAction(\"Parsed Result\")}:`,\n\t\t\t\t\t{ model, data: transformed },\n\t\t\t\t);\n\t\t\t\treturn transformed;\n\t\t\t},\n\t\t\tupdateMany: async ({\n\t\t\t\tmodel: unsafeModel,\n\t\t\t\twhere: unsafeWhere,\n\t\t\t\tupdate: unsafeData,\n\t\t\t}: {\n\t\t\t\tmodel: string;\n\t\t\t\twhere: Where[];\n\t\t\t\tupdate: Record<string, any>;\n\t\t\t}) => {\n\t\t\t\ttransactionId++;\n\t\t\t\tconst thisTransactionId = transactionId;\n\t\t\t\tconst model = getModelName(unsafeModel);\n\t\t\t\tconst where = transformWhereClause({\n\t\t\t\t\tmodel: unsafeModel,\n\t\t\t\t\twhere: unsafeWhere,\n\t\t\t\t\taction: \"updateMany\",\n\t\t\t\t});\n\t\t\t\tunsafeModel = getDefaultModelName(unsafeModel);\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"updateMany\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(1, 4)}`,\n\t\t\t\t\t`${formatMethod(\"updateMany\")} ${formatAction(\"Unsafe Input\")}:`,\n\t\t\t\t\t{ model, data: unsafeData },\n\t\t\t\t);\n\t\t\t\tlet data = unsafeData;\n\t\t\t\tif (!config.disableTransformInput) {\n\t\t\t\t\tdata = await transformInput(unsafeData, unsafeModel, \"update\");\n\t\t\t\t}\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"updateMany\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(2, 4)}`,\n\t\t\t\t\t`${formatMethod(\"updateMany\")} ${formatAction(\"Parsed Input\")}:`,\n\t\t\t\t\t{ model, data },\n\t\t\t\t);\n\n\t\t\t\tconst updatedCount = await adapterInstance.updateMany({\n\t\t\t\t\tmodel,\n\t\t\t\t\twhere,\n\t\t\t\t\tupdate: data,\n\t\t\t\t});\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"updateMany\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(3, 4)}`,\n\t\t\t\t\t`${formatMethod(\"updateMany\")} ${formatAction(\"DB Result\")}:`,\n\t\t\t\t\t{ model, data: updatedCount },\n\t\t\t\t);\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"updateMany\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(4, 4)}`,\n\t\t\t\t\t`${formatMethod(\"updateMany\")} ${formatAction(\"Parsed Result\")}:`,\n\t\t\t\t\t{ model, data: updatedCount },\n\t\t\t\t);\n\t\t\t\treturn updatedCount;\n\t\t\t},\n\t\t\tfindOne: async <T extends Record<string, any>>({\n\t\t\t\tmodel: unsafeModel,\n\t\t\t\twhere: unsafeWhere,\n\t\t\t\tselect,\n\t\t\t\tjoin: unsafeJoin,\n\t\t\t}: {\n\t\t\t\tmodel: string;\n\t\t\t\twhere: Where[];\n\t\t\t\tselect?: string[];\n\t\t\t\tjoin?: JoinOption;\n\t\t\t}) => {\n\t\t\t\ttransactionId++;\n\t\t\t\tconst thisTransactionId = transactionId;\n\t\t\t\tconst model = getModelName(unsafeModel);\n\t\t\t\tconst where = transformWhereClause({\n\t\t\t\t\tmodel: unsafeModel,\n\t\t\t\t\twhere: unsafeWhere,\n\t\t\t\t\taction: \"findOne\",\n\t\t\t\t});\n\t\t\t\tunsafeModel = getDefaultModelName(unsafeModel);\n\t\t\t\tlet join: JoinConfig | undefined;\n\t\t\t\tlet passJoinToAdapter = true;\n\t\t\t\tif (!config.disableTransformJoin) {\n\t\t\t\t\tconst result = transformJoinClause(unsafeModel, unsafeJoin, select);\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tjoin = result.join;\n\t\t\t\t\t\tselect = result.select;\n\t\t\t\t\t}\n\t\t\t\t\t// If adapter doesn't support joins and we have joins, don't pass them to the adapter\n\t\t\t\t\tconst experimentalJoins = options.experimental?.joins;\n\t\t\t\t\tif (!experimentalJoins && join && Object.keys(join).length > 0) {\n\t\t\t\t\t\tpassJoinToAdapter = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// assume it's already transformed if transformation is disabled\n\t\t\t\t\tjoin = unsafeJoin as never as JoinConfig;\n\t\t\t\t}\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"findOne\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(1, 3)}`,\n\t\t\t\t\t`${formatMethod(\"findOne\")}:`,\n\t\t\t\t\t{ model, where, select, join },\n\t\t\t\t);\n\n\t\t\t\tconst res = await adapterInstance.findOne<T>({\n\t\t\t\t\tmodel,\n\t\t\t\t\twhere,\n\t\t\t\t\tselect,\n\t\t\t\t\tjoin: passJoinToAdapter ? join : undefined,\n\t\t\t\t});\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"findOne\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(2, 3)}`,\n\t\t\t\t\t`${formatMethod(\"findOne\")} ${formatAction(\"DB Result\")}:`,\n\t\t\t\t\t{ model, data: res },\n\t\t\t\t);\n\n\t\t\t\t// Handle fallback join if adapter doesn't support joins\n\t\t\t\tlet transformed = res as any;\n\t\t\t\tif (!config.disableTransformOutput) {\n\t\t\t\t\ttransformed = await transformOutput(res, unsafeModel, select, join);\n\t\t\t\t}\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"findOne\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(3, 3)}`,\n\t\t\t\t\t`${formatMethod(\"findOne\")} ${formatAction(\"Parsed Result\")}:`,\n\t\t\t\t\t{ model, data: transformed },\n\t\t\t\t);\n\t\t\t\treturn transformed;\n\t\t\t},\n\t\t\tfindMany: async <T extends Record<string, any>>({\n\t\t\t\tmodel: unsafeModel,\n\t\t\t\twhere: unsafeWhere,\n\t\t\t\tlimit: unsafeLimit,\n\t\t\t\tsortBy,\n\t\t\t\toffset,\n\t\t\t\tjoin: unsafeJoin,\n\t\t\t}: {\n\t\t\t\tmodel: string;\n\t\t\t\twhere?: Where[];\n\t\t\t\tlimit?: number;\n\t\t\t\tsortBy?: { field: string; direction: \"asc\" | \"desc\" };\n\t\t\t\toffset?: number;\n\t\t\t\tjoin?: JoinOption;\n\t\t\t}) => {\n\t\t\t\ttransactionId++;\n\t\t\t\tconst thisTransactionId = transactionId;\n\t\t\t\tconst limit =\n\t\t\t\t\tunsafeLimit ??\n\t\t\t\t\toptions.advanced?.database?.defaultFindManyLimit ??\n\t\t\t\t\t100;\n\t\t\t\tconst model = getModelName(unsafeModel);\n\t\t\t\tconst where = transformWhereClause({\n\t\t\t\t\tmodel: unsafeModel,\n\t\t\t\t\twhere: unsafeWhere,\n\t\t\t\t\taction: \"findMany\",\n\t\t\t\t});\n\t\t\t\tunsafeModel = getDefaultModelName(unsafeModel);\n\t\t\t\tlet join: JoinConfig | undefined;\n\t\t\t\tlet passJoinToAdapter = true;\n\t\t\t\tif (!config.disableTransformJoin) {\n\t\t\t\t\tconst result = transformJoinClause(\n\t\t\t\t\t\tunsafeModel,\n\t\t\t\t\t\tunsafeJoin,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t);\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tjoin = result.join;\n\t\t\t\t\t}\n\t\t\t\t\t// If adapter doesn't support joins and we have joins, don't pass them to the adapter\n\t\t\t\t\tconst experimentalJoins = options.experimental?.joins;\n\t\t\t\t\tif (!experimentalJoins && join && Object.keys(join).length > 0) {\n\t\t\t\t\t\tpassJoinToAdapter = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// assume it's already transformed if transformation is disabled\n\t\t\t\t\tjoin = unsafeJoin as never as JoinConfig;\n\t\t\t\t}\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"findMany\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(1, 3)}`,\n\t\t\t\t\t`${formatMethod(\"findMany\")}:`,\n\t\t\t\t\t{ model, where, limit, sortBy, offset, join },\n\t\t\t\t);\n\t\t\t\tconst res = await adapterInstance.findMany<T>({\n\t\t\t\t\tmodel,\n\t\t\t\t\twhere,\n\t\t\t\t\tlimit: limit,\n\t\t\t\t\tsortBy,\n\t\t\t\t\toffset,\n\t\t\t\t\tjoin: passJoinToAdapter ? join : undefined,\n\t\t\t\t});\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"findMany\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(2, 3)}`,\n\t\t\t\t\t`${formatMethod(\"findMany\")} ${formatAction(\"DB Result\")}:`,\n\t\t\t\t\t{ model, data: res },\n\t\t\t\t);\n\n\t\t\t\tlet transformed = res as any;\n\t\t\t\tif (!config.disableTransformOutput) {\n\t\t\t\t\ttransformed = await Promise.all(\n\t\t\t\t\t\tres.map(async (r: Record<string, any>) => {\n\t\t\t\t\t\t\treturn await transformOutput(r, unsafeModel, undefined, join);\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"findMany\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(3, 3)}`,\n\t\t\t\t\t`${formatMethod(\"findMany\")} ${formatAction(\"Parsed Result\")}:`,\n\t\t\t\t\t{ model, data: transformed },\n\t\t\t\t);\n\t\t\t\treturn transformed;\n\t\t\t},\n\t\t\tdelete: async ({\n\t\t\t\tmodel: unsafeModel,\n\t\t\t\twhere: unsafeWhere,\n\t\t\t}: {\n\t\t\t\tmodel: string;\n\t\t\t\twhere: Where[];\n\t\t\t}) => {\n\t\t\t\ttransactionId++;\n\t\t\t\tconst thisTransactionId = transactionId;\n\t\t\t\tconst model = getModelName(unsafeModel);\n\t\t\t\tconst where = transformWhereClause({\n\t\t\t\t\tmodel: unsafeModel,\n\t\t\t\t\twhere: unsafeWhere,\n\t\t\t\t\taction: \"delete\",\n\t\t\t\t});\n\t\t\t\tunsafeModel = getDefaultModelName(unsafeModel);\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"delete\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(1, 2)}`,\n\t\t\t\t\t`${formatMethod(\"delete\")}:`,\n\t\t\t\t\t{ model, where },\n\t\t\t\t);\n\t\t\t\tawait adapterInstance.delete({\n\t\t\t\t\tmodel,\n\t\t\t\t\twhere,\n\t\t\t\t});\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"delete\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(2, 2)}`,\n\t\t\t\t\t`${formatMethod(\"delete\")} ${formatAction(\"DB Result\")}:`,\n\t\t\t\t\t{ model },\n\t\t\t\t);\n\t\t\t},\n\t\t\tdeleteMany: async ({\n\t\t\t\tmodel: unsafeModel,\n\t\t\t\twhere: unsafeWhere,\n\t\t\t}: {\n\t\t\t\tmodel: string;\n\t\t\t\twhere: Where[];\n\t\t\t}) => {\n\t\t\t\ttransactionId++;\n\t\t\t\tconst thisTransactionId = transactionId;\n\t\t\t\tconst model = getModelName(unsafeModel);\n\t\t\t\tconst where = transformWhereClause({\n\t\t\t\t\tmodel: unsafeModel,\n\t\t\t\t\twhere: unsafeWhere,\n\t\t\t\t\taction: \"deleteMany\",\n\t\t\t\t});\n\t\t\t\tunsafeModel = getDefaultModelName(unsafeModel);\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"deleteMany\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(1, 2)}`,\n\t\t\t\t\t`${formatMethod(\"deleteMany\")} ${formatAction(\"DeleteMany\")}:`,\n\t\t\t\t\t{ model, where },\n\t\t\t\t);\n\t\t\t\tconst res = await adapterInstance.deleteMany({\n\t\t\t\t\tmodel,\n\t\t\t\t\twhere,\n\t\t\t\t});\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"deleteMany\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(2, 2)}`,\n\t\t\t\t\t`${formatMethod(\"deleteMany\")} ${formatAction(\"DB Result\")}:`,\n\t\t\t\t\t{ model, data: res },\n\t\t\t\t);\n\t\t\t\treturn res;\n\t\t\t},\n\t\t\tcount: async ({\n\t\t\t\tmodel: unsafeModel,\n\t\t\t\twhere: unsafeWhere,\n\t\t\t}: {\n\t\t\t\tmodel: string;\n\t\t\t\twhere?: Where[];\n\t\t\t}) => {\n\t\t\t\ttransactionId++;\n\t\t\t\tconst thisTransactionId = transactionId;\n\t\t\t\tconst model = getModelName(unsafeModel);\n\t\t\t\tconst where = transformWhereClause({\n\t\t\t\t\tmodel: unsafeModel,\n\t\t\t\t\twhere: unsafeWhere,\n\t\t\t\t\taction: \"count\",\n\t\t\t\t});\n\t\t\t\tunsafeModel = getDefaultModelName(unsafeModel);\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"count\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(1, 2)}`,\n\t\t\t\t\t`${formatMethod(\"count\")}:`,\n\t\t\t\t\t{\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t\tconst res = await adapterInstance.count({\n\t\t\t\t\tmodel,\n\t\t\t\t\twhere,\n\t\t\t\t});\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"count\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(2, 2)}`,\n\t\t\t\t\t`${formatMethod(\"count\")}:`,\n\t\t\t\t\t{\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tdata: res,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t\treturn res;\n\t\t\t},\n\t\t\tcreateSchema: adapterInstance.createSchema\n\t\t\t\t? async (_, file) => {\n\t\t\t\t\t\tconst tables = getAuthTables(options);\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\toptions.secondaryStorage &&\n\t\t\t\t\t\t\t!options.session?.storeSessionInDatabase\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// biome-ignore lint/performance/noDelete: If the user has enabled secondaryStorage, as well as not specifying to store session table in DB, then createSchema shouldn't generate schema table.\n\t\t\t\t\t\t\tdelete tables.session;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn adapterInstance.createSchema!({ file, tables });\n\t\t\t\t\t}\n\t\t\t\t: undefined,\n\t\t\toptions: {\n\t\t\t\tadapterConfig: config,\n\t\t\t\t...(adapterInstance.options ?? {}),\n\t\t\t},\n\t\t\tid: config.adapterId,\n\n\t\t\t// Secretly export values ONLY if this adapter has enabled adapter-test-debug-logs.\n\t\t\t// This would then be used during our adapter-tests to help print debug logs if a test fails.\n\t\t\t//@ts-expect-error - ^^\n\t\t\t...(config.debugLogs?.isRunningAdapterTests\n\t\t\t\t? {\n\t\t\t\t\t\tadapterTestDebugLogs: {\n\t\t\t\t\t\t\tresetDebugLogs() {\n\t\t\t\t\t\t\t\tdebugLogs = debugLogs.filter(\n\t\t\t\t\t\t\t\t\t(log) => log.instance !== uniqueAdapterFactoryInstanceId,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tprintDebugLogs() {\n\t\t\t\t\t\t\t\tconst separator = `â”€`.repeat(80);\n\t\t\t\t\t\t\t\tconst logs = debugLogs.filter(\n\t\t\t\t\t\t\t\t\t(log) => log.instance === uniqueAdapterFactoryInstanceId,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (logs.length === 0) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t//`${colors.fg.blue}|${colors.reset} `,\n\t\t\t\t\t\t\t\tconst log: any[] = logs\n\t\t\t\t\t\t\t\t\t.reverse()\n\t\t\t\t\t\t\t\t\t.map((log) => {\n\t\t\t\t\t\t\t\t\t\tlog.args[0] = `\\n${log.args[0]}`;\n\t\t\t\t\t\t\t\t\t\treturn [...log.args, \"\\n\"];\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t.reduce(\n\t\t\t\t\t\t\t\t\t\t(prev, curr) => {\n\t\t\t\t\t\t\t\t\t\t\treturn [...curr, ...prev];\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t[`\\n${separator}`],\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tconsole.log(...log);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t} satisfies AdapterTestDebugLogs,\n\t\t\t\t\t}\n\t\t\t\t: {}),\n\t\t};\n\t\treturn adapter;\n\t};\n\nfunction formatTransactionId(transactionId: number) {\n\tif (getColorDepth() < 8) {\n\t\treturn `#${transactionId}`;\n\t}\n\treturn `${TTY_COLORS.fg.magenta}#${transactionId}${TTY_COLORS.reset}`;\n}\n\nfunction formatStep(step: number, total: number) {\n\treturn `${TTY_COLORS.bg.black}${TTY_COLORS.fg.yellow}[${step}/${total}]${TTY_COLORS.reset}`;\n}\n\nfunction formatMethod(method: string) {\n\treturn `${TTY_COLORS.bright}${method}${TTY_COLORS.reset}`;\n}\n\nfunction formatAction(action: string) {\n\treturn `${TTY_COLORS.dim}(${action})${TTY_COLORS.reset}`;\n}\n\n/**\n * @deprecated Use `createAdapterFactory` instead. This export will be removed in a future version.\n * @alias\n */\nexport const createAdapter = createAdapterFactory;\n"],"mappings":"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"}