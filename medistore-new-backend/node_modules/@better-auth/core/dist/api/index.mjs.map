{"version":3,"file":"index.mjs","names":["path: Path | undefined","options: Opts","handler: EndpointHandler<Path, Opts, R>"],"sources":["../../src/api/index.ts"],"sourcesContent":["import type {\n\tEndpointContext,\n\tEndpointOptions,\n\tStrictEndpoint,\n} from \"better-call\";\nimport { createEndpoint, createMiddleware } from \"better-call\";\nimport { runWithEndpointContext } from \"../context\";\nimport type { AuthContext } from \"../types\";\n\nexport const optionsMiddleware = createMiddleware(async () => {\n\t/**\n\t * This will be passed on the instance of\n\t * the context. Used to infer the type\n\t * here.\n\t */\n\treturn {} as AuthContext;\n});\n\nexport const createAuthMiddleware = createMiddleware.create({\n\tuse: [\n\t\toptionsMiddleware,\n\t\t/**\n\t\t * Only use for post hooks\n\t\t */\n\t\tcreateMiddleware(async () => {\n\t\t\treturn {} as {\n\t\t\t\treturned?: unknown | undefined;\n\t\t\t\tresponseHeaders?: Headers | undefined;\n\t\t\t};\n\t\t}),\n\t],\n});\n\nconst use = [optionsMiddleware];\n\ntype EndpointHandler<\n\tPath extends string,\n\tOptions extends EndpointOptions,\n\tR,\n> = (context: EndpointContext<Path, Options, AuthContext>) => Promise<R>;\n\nexport function createAuthEndpoint<\n\tPath extends string,\n\tOptions extends EndpointOptions,\n\tR,\n>(\n\tpath: Path,\n\toptions: Options,\n\thandler: EndpointHandler<Path, Options, R>,\n): StrictEndpoint<Path, Options, R>;\n\nexport function createAuthEndpoint<\n\tPath extends string,\n\tOptions extends EndpointOptions,\n\tR,\n>(\n\toptions: Options,\n\thandler: EndpointHandler<Path, Options, R>,\n): StrictEndpoint<Path, Options, R>;\n\nexport function createAuthEndpoint<\n\tPath extends string,\n\tOpts extends EndpointOptions,\n\tR,\n>(\n\tpathOrOptions: Path | Opts,\n\thandlerOrOptions: EndpointHandler<Path, Opts, R> | Opts,\n\thandlerOrNever?: any,\n) {\n\tconst path: Path | undefined =\n\t\ttypeof pathOrOptions === \"string\" ? pathOrOptions : undefined;\n\tconst options: Opts =\n\t\ttypeof handlerOrOptions === \"object\"\n\t\t\t? handlerOrOptions\n\t\t\t: (pathOrOptions as Opts);\n\tconst handler: EndpointHandler<Path, Opts, R> =\n\t\ttypeof handlerOrOptions === \"function\" ? handlerOrOptions : handlerOrNever;\n\n\tif (path) {\n\t\treturn createEndpoint(\n\t\t\tpath,\n\t\t\t{\n\t\t\t\t...options,\n\t\t\t\tuse: [...(options?.use || []), ...use],\n\t\t\t},\n\t\t\t// todo: prettify the code, we want to call `runWithEndpointContext` to top level\n\t\t\tasync (ctx) => runWithEndpointContext(ctx as any, () => handler(ctx)),\n\t\t);\n\t}\n\n\treturn createEndpoint(\n\t\t{\n\t\t\t...options,\n\t\t\tuse: [...(options?.use || []), ...use],\n\t\t},\n\t\t// todo: prettify the code, we want to call `runWithEndpointContext` to top level\n\t\tasync (ctx) => runWithEndpointContext(ctx as any, () => handler(ctx)),\n\t);\n}\n\nexport type AuthEndpoint<\n\tPath extends string,\n\tOpts extends EndpointOptions,\n\tR,\n> = ReturnType<typeof createAuthEndpoint<Path, Opts, R>>;\nexport type AuthMiddleware = ReturnType<typeof createAuthMiddleware>;\n"],"mappings":";;;;;AASA,MAAa,oBAAoB,iBAAiB,YAAY;;;;;;AAM7D,QAAO,EAAE;EACR;AAEF,MAAa,uBAAuB,iBAAiB,OAAO,EAC3D,KAAK,CACJ,mBAIA,iBAAiB,YAAY;AAC5B,QAAO,EAAE;EAIR,CACF,EACD,CAAC;AAEF,MAAM,MAAM,CAAC,kBAAkB;AA2B/B,SAAgB,mBAKf,eACA,kBACA,gBACC;CACD,MAAMA,OACL,OAAO,kBAAkB,WAAW,gBAAgB;CACrD,MAAMC,UACL,OAAO,qBAAqB,WACzB,mBACC;CACL,MAAMC,UACL,OAAO,qBAAqB,aAAa,mBAAmB;AAE7D,KAAI,KACH,QAAO,eACN,MACA;EACC,GAAG;EACH,KAAK,CAAC,GAAI,SAAS,OAAO,EAAE,EAAG,GAAG,IAAI;EACtC,EAED,OAAO,QAAQ,uBAAuB,WAAkB,QAAQ,IAAI,CAAC,CACrE;AAGF,QAAO,eACN;EACC,GAAG;EACH,KAAK,CAAC,GAAI,SAAS,OAAO,EAAE,EAAG,GAAG,IAAI;EACtC,EAED,OAAO,QAAQ,uBAAuB,WAAkB,QAAQ,IAAI,CAAC,CACrE"}